#!/usr/bin/env ruby
# frozen_string_literal: true

# Computes the result
#
# Input 1: Extended JSON IR of syntax highlighted source code
# Input 2: JSON IR of BDF font
# Output:  Result hash in JSON format

require 'json'
require 'yaml'

def effective_area(width:, height:, line_height_factor:)
  width_effective  = width + 2
  height_effective = ((height + 2) * line_height_factor).round

  width_effective * height_effective
end

def process(source_hash, font_hash, meta_hash)
  colors = source_hash['codes'].map do |code|
    code['color']['value']
  end.tally

  cct_background     = source_hash['style']['background-color']['cct']
  line_height_factor = source_hash['style']['line-height'].to_f / source_hash['style']['font-size'].to_f

  effective_area= effective_area(width: font_hash['width'],
                                 height: font_hash['height'],
                                 line_height_factor: line_height_factor)

  cccts = source_hash['codes'].map do |code|
    cct = code['color']['cct'] || 0.0
    code['content'].chars.map do |char|
      h = font_hash['chars'][char]

      if char == ' '
        # Boşluk karakteri özel.  Boşluklar için HTML'de span içinde bir renk bildiriliyor ama bunun bir önemi
        # yok.  Neden? Çünkü boşluklarda CSS background rengiyle overwrite ediyor.  Dolayısıyla boşluklar
        # için kaynak temsilinde bildirilen renk yerine background rengini esas alıyoruz.
        next cct_background
      elsif h['ones'].nil?
        # Muhtelemen bir kontrol karakteri, yani printable değil. BDF'te bu tür karakterler için bitmap boş.
        # Dolayısıyla bu karakterlerin CCT katkısı 0.0.
        next 0.0
      end

      count1 = h['ones']
      count0 = effective_area - count1

      # 0'lar background rengiyle, 1'ler ise bildirilen renkle katkı sağlıyor
      # Formül:
      #
      #   ((1'lerin sayısı) x (bildirilen renk CCT)) + ((0'ların sayısı) x (arkaplan CCT))
      #   -------------------------------------------------------------------------------
      #                             toplam piksel sayısı
      ((count1 * cct) + (count0 * cct_background)) / effective_area.to_f
    end
  end.flatten.tally

  average = cccts.sum { |k, v| k * v } / cccts.values.sum.to_f
  diff65  = 100.0 * (average - 6500.0) / 6500.0

  warn "    Average CCCT: #{average.round(2)}"

  {
    colors:  Hash[colors.sort_by { |k, v| [-v, k] }],
    cccts:   Hash[cccts.sort_by  { |k, v| [-v, k] }],
    source:  meta_hash,
    average: average,
    diff65:  diff65,
    cctbg:   cct_background
  }
end

def main
  meta_hash = YAML.load_file(ARGV.pop)
  source_hash, font_hash = ARGV.map { |file| JSON.parse File.read(file) }

  puts JSON.pretty_generate process(source_hash, font_hash, meta_hash)
end

main
