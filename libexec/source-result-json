#!/usr/bin/env ruby
# frozen_string_literal: true

# Computes the result
#
# Input 1: Extended JSON IR of syntax highlighted source code
# Input 2: JSON IR of BDF font
# Output:  Result hash in JSON format

require 'json'
require 'yaml'

def process(source_hash, font_hash, meta_hash)
  colors = source_hash['codes'].map do |code|
    code['color']['value']
  end.tally

  cct_background      = source_hash['style']['background-color']['cct']
  vertical_row_factor = source_hash['style']['line-height'].to_f / source_hash['style']['font-size'].to_f

  cccts = source_hash['codes'].map do |code|
    cct = code['color']['cct'] || 0.0
    code['content'].chars.map do |char|
      h = font_hash[char]

      if char == ' '
        # Boşluk karakteri özel.  Boşluklar için HTML'de span içinde bir renk bildiriliyor ama bunun bir önemi
        # yok.  Neden? Çünkü boşluklarda CSS background rengiyle overwrite ediyor.  Dolayısıyla boşluklar
        # için kaynak temsilinde bildirilen renk yerine background rengini esas alıyoruz.
        next cct_background
      elsif h['count1'].nil?
        # Muhtelemen bir kontrol karakteri, yani printable değil. BDF'te bu tür karakterler için bitmap boş.
        # Dolayısıyla bu karakterlerin CCT katkısı 0.0.
        next 0.0
      end

      # Line-height'ten gelen üst ve alt pikselleri hesaba katmaya hazırlanıyoruz.  Bu pikseller 0 yani background
      # rengi olarak katkı sağlayacak.
      extra_rows = (vertical_row_factor * h['nrows']).round
      extra_area = extra_rows * h['ncols']

      areafull = h['areafull'] + extra_area
      count0   = h['count0']   + extra_area # Line-height katkısı
      count1   = h['count1']

      # 0'lar background rengiyle, 1'ler ise bildirilen renkle katkı sağlıyor
      # Formül:
      #
      #   ((1'lerin sayısı) x (bildirilen renk CCT)) + ((0'ların sayısı) x (arkaplan CCT))
      #   -------------------------------------------------------------------------------
      #                             toplam piksel sayısı
      ((count1 * cct) + (count0 * cct_background)) / areafull.to_f
    end
  end.flatten.tally

  average = cccts.sum { |k, v| k * v } / cccts.values.sum.to_f
  diff65  = 100.0 * (average - 6500.0) / 6500.0

  warn "    Average CCCT: #{average.round(2)}"

  {
    colors:  Hash[colors.sort_by { |k, v| [-v, k] }],
    cccts:   Hash[cccts.sort_by  { |k, v| [-v, k] }],
    source:  meta_hash,
    average: average,
    diff65:  diff65
  }
end

def main
  meta_hash = YAML.load_file(ARGV.pop)
  source_hash, font_hash = ARGV.map { |file| JSON.parse File.read(file) }

  puts JSON.pretty_generate process(source_hash, font_hash, meta_hash)
end

main
