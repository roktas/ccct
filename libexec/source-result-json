#!/usr/bin/env ruby
# frozen_string_literal: true

# Computes the result
#
# Input 1: Extended JSON IR of syntax highlighted source code
# Input 2: JSON IR of BDF font
# Output:  Result hash in JSON format

require 'json'
require 'yaml'

def effective_area(width:, height:, line_height_factor:)
  width_effective  = width + 2
  height_effective = ((height + 2) * line_height_factor).round

  width_effective * height_effective
end

def preprocess(source_hash, font_hash, meta_hash)
  background_color   = source_hash['style']['background-color']['value']
  background_cct     = source_hash['style']['background-color']['cct']
  line_height_factor = source_hash['style']['line-height'].to_f / source_hash['style']['font-size'].to_f

  source_hash['codes'].map do |code|
    next unless code['content'].strip.empty?
    code['color']['value'] = background_color
  end

  colors_tally = source_hash['codes'].map do |code|
    code['color']['value']
  end.tally

  colors = {}
  source_hash['codes'].each do |code|
    colors[color = code['color']['value']] = {
      cct: code['color']['cct'],
      frequency: colors_tally[color]
    }
  end

  effective_area= effective_area(width:              font_hash['width'],
                                 height:             font_hash['height'],
                                 line_height_factor: line_height_factor)

  cccts = source_hash['codes'].map do |code|
    cct = code['color']['cct'] || 0.0
    code['content'].chars.map do |char|
      h = font_hash['chars'][char]

      if char == ' '
        # Boşluk karakteri özel.  Boşluklar için HTML'de span içinde bir renk bildiriliyor ama bunun bir önemi
        # yok.  Neden? Çünkü boşluklarda CSS background rengiyle overwrite ediyor.  Dolayısıyla boşluklar
        # için kaynak temsilinde bildirilen renk yerine background rengini esas alıyoruz.
        next background_cct
      elsif h['ones'].nil?
        # Muhtelemen bir kontrol karakteri, yani printable değil. BDF'te bu tür karakterler için bitmap boş.
        # Dolayısıyla bu karakterlerin CCT katkısı 0.0.
        next 0.0
      end

      count1 = h['ones']
      count0 = effective_area - count1

      # 0'lar background rengiyle, 1'ler ise bildirilen renkle katkı sağlıyor
      # Formül:
      #
      #   ((1'lerin sayısı) x (bildirilen renk CCT)) + ((0'ların sayısı) x (arkaplan CCT))
      #   -------------------------------------------------------------------------------
      #                             toplam piksel sayısı
      ((count1 * cct) + (count0 * background_cct)) / effective_area.to_f
    end
  end.flatten.tally

  {
    colors:                         Hash[colors.sort_by { |_, v| -v[:frequency] }],
    cccts:                          Hash[cccts.sort_by  { |k, v| [-v, k] }],
    source:                         meta_hash,
    background_cct:                 background_cct
  }
end

# Average CCT 1: Filter out-of-bound CCT values and, ignore in the calculation.
def average_cct_1(result)
  cccts = result[:cccts].reject { |cct, count| cct > 20_000 || cct < 1000 }

  cccts.sum { |cct, count| cct * count } / cccts.values.sum.to_f
end

# Average CCT 2: Crop out-of-bound CCT values.
def average_cct_2(result)
  cccts = result[:cccts].transform_keys do |cct|
    if cct > 20_000
      20_0001
    elsif cct < 1000
      999
    else
      cct
    end
  end

  cccts.sum { |cct, count| cct * count } / cccts.values.sum.to_f
end

# Average CCT 3: Keep out-of-bound CCT values and, add them to the calculation as is.
def average_cct_3(result)
  cccts = result[:cccts]
  cccts.sum { |cct, count| cct * count } / cccts.values.sum.to_f
end

def apply_method(name, average_cct)
  warn "    #{name} - Average CCCT                   : #{average_cct.round(2)}"

  {
    average_cct: average_cct,
    diff65: 100.0 * (average_cct - 6500.0) / 6500.0
  }
end

def process(source_hash, font_hash, meta_hash)
  result = preprocess(source_hash, font_hash, meta_hash)

  result[:h1] = apply_method 'Method 1', average_cct_1(result)
  result[:h2] = apply_method 'Method 2', average_cct_2(result)
  result[:h3] = apply_method 'Method 3', average_cct_3(result)

  result
end

def main
  meta_hash = YAML.load_file(ARGV.pop)
  source_hash, font_hash = ARGV.map { |file| JSON.parse File.read(file) }

  puts JSON.pretty_generate process(source_hash, font_hash, meta_hash)
end

main
