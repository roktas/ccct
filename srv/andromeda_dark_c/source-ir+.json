{
  "codes": [
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"cache.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"config.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"grep.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"object-store.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"userdiff.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"xdiff-interface.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"diff.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"diffcore.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"commit.h\""
    },
    {
      "color": {
        "cct": 146911.42,
        "value": "#c74ded"
      },
      "content": "#include"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " quote.h"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\""
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#include \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "help.h"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\""
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_load(struct grep_source *gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_is_binary(struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0struct index_state *istate);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void std_output(struct grep_opt *opt, const void *buf, size_t size)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 fwrite(buf, size, 1, stdout);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_opt grep_defaults = {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .relative = 1,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .pathname = 1,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .max_depth = -1,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .pattern_type_option = GREP_PATTERN_TYPE_UNSPECIFIED,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .colors = {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_CONTEXT] = \"\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_FILENAME] = GIT_COLOR_MAGENTA,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_FUNCTION] = \"\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_LINENO] = GIT_COLOR_GREEN,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_COLUMNNO] = GIT_COLOR_GREEN,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_MATCH_CONTEXT] = GIT_COLOR_BOLD_RED,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_MATCH_SELECTED] = GIT_COLOR_BOLD_RED,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_SELECTED] = \"\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 [GREP_COLOR_SEP] = GIT_COLOR_CYAN,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 },"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .only_matching = 0,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .color = -1,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 .output = std_output,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "};"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static const char *color_grep_slots[] = {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_CONTEXT] \u00a0 \u00a0 \u00a0 \u00a0= \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "context"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_FILENAME] \u00a0 \u00a0 \u00a0 = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "filename"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_FUNCTION] \u00a0 \u00a0 \u00a0 = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "function"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_LINENO] \u00a0 \u00a0 = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "lineNumber"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_COLUMNNO] \u00a0 \u00a0 \u00a0 = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "column"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_MATCH_CONTEXT] \u00a0= \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "matchContext"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_MATCH_SELECTED] = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "matchSelected"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_SELECTED] \u00a0 \u00a0 \u00a0 = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "selected"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 [GREP_COLOR_SEP] \u00a0 \u00a0 \u00a0 \u00a0= \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "separator"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "};"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int parse_pattern_type_arg(const char *opt, const char *arg)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(arg, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "default"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return GREP_PATTERN_TYPE_UNSPECIFIED;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (!strcmp(arg, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "basic"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return GREP_PATTERN_TYPE_BRE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (!strcmp(arg, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "extended"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return GREP_PATTERN_TYPE_ERE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (!strcmp(arg, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "fixed"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return GREP_PATTERN_TYPE_FIXED;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (!strcmp(arg, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "perl"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return GREP_PATTERN_TYPE_PCRE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "bad %s argument: %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", opt, arg);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "define_list_config_array_extra(color_grep_slots, {\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "match"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"});"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "/*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* Read the configuration file once and store it in"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* the grep_defaults template."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "int grep_config(const char *var, const char *value, void *cb)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_opt *opt = &grep_defaults;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *slot;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (userdiff_config(var, value) < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* The instance of grep_opt that we set up here is copied by"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* grep_init() to be used by each individual invocation."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* When populating a new field of this structure here, be"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* sure to think about ownership -- e.g., you might need to"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* override the shallow copy in grep_init() with a deep copy."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep.extendedregexp"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->extended_regexp_option = git_config_bool(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep.patterntype"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_type_option = parse_pattern_type_arg(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep.linenumber"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->linenum = git_config_bool(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep.column"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->columnnum = git_config_bool(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep.fullname"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->relative = !git_config_bool(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "color.grep"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->color = git_config_colorbool(var, value);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!strcmp(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "color.grep.match"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\")) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (grep_config(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "color.grep.matchcontext"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", value, cb) < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (grep_config(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "color.grep.matchselected"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", value, cb) < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 } else if (skip_prefix(var, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "color.grep."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", &slot)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 int i = LOOKUP_CONFIG(color_grep_slots, slot);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char *color;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (i < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 color = opt->colors[i];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!value)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return config_error_nonbool(var);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return color_parse(value, color);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "/*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* Initialize one instance of grep_opt and copy the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* default values from the template we read the configuration"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* information in an earlier call to git_config(grep_config)."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_init(struct grep_opt *opt, struct repository *repo, const char *prefix)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *opt = grep_defaults;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->repo = repo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->prefix = prefix;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->prefix_length = (prefix && *prefix) ? strlen(prefix) : 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->pattern_tail = &opt->pattern_list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->header_tail = &opt->header_list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void grep_set_pattern_type_option(enum grep_pattern_type pattern_type, struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* When committing to the pattern type by setting the relevant"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* fields in grep_opt it's generally not necessary to zero out"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* the fields we're not choosing, since they won't have been"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* set by anything. The extended_regexp_option field is the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* only exception to this."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* This is because in the process of parsing grep.patternType"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* & grep.extendedRegexp we set opt->pattern_type_option and"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* opt->extended_regexp_option, respectively. We then"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* internally use opt->extended_regexp_option to see if we're"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* compiling an ERE. It must be unset if that's not actually"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* the case."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (pattern_type != GREP_PATTERN_TYPE_ERE &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->extended_regexp_option)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->extended_regexp_option = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (pattern_type) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_TYPE_UNSPECIFIED:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* fall through */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_TYPE_BRE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_TYPE_ERE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->extended_regexp_option = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_TYPE_FIXED:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->fixed = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_TYPE_PCRE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pcre2 = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_commit_pattern_type(enum grep_pattern_type pattern_type, struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (pattern_type != GREP_PATTERN_TYPE_UNSPECIFIED)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_set_pattern_type_option(pattern_type, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (opt->pattern_type_option != GREP_PATTERN_TYPE_UNSPECIFIED)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_set_pattern_type_option(opt->pattern_type_option, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (opt->extended_regexp_option)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* This branch *must* happen after setting from the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* opt->pattern_type_option above, we don't want"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* grep.extendedRegexp to override grep.patternType!"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_set_pattern_type_option(GREP_PATTERN_TYPE_ERE, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_pat *create_grep_pat(const char *pat, size_t patlen,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *origin, int no,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_pat_token t,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_header_field field)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p = xcalloc(1, sizeof(*p));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->pattern = xmemdupz(pat, patlen);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->patternlen = patlen;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->origin = origin;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->no = no;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->token = t;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->field = field;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void do_append_grep_pat(struct grep_pat ***tail, struct grep_pat *p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 **tail = p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *tail = &p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->next = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN: /* atom */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_HEAD:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_BODY:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 for (;;) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 struct grep_pat *new_pat;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t len = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 char *cp = p->pattern + p->patternlen, *nl = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while (++len <= p->patternlen) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (*(--cp) == '\\n') {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 nl = cp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!nl)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 new_pat = create_grep_pat(nl + 1, len - 1, p->origin,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->no, p->token, p->field);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 new_pat->next = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!p->next)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 *tail = &new_pat->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->next = new_pat;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 *nl = '\\0';"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->patternlen -= len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void append_header_grep_pattern(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_header_field field, const char *pat)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p = create_grep_pat(pat, strlen(pat), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "header"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 0,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0GREP_PATTERN_HEAD, field);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (field == GREP_HEADER_REFLOG)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->use_reflog_filter = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 do_append_grep_pat(&opt->header_tail, p);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void append_grep_pattern(struct grep_opt *opt, const char *pat,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *origin, int no, enum grep_pat_token t)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 append_grep_pat(opt, pat, strlen(pat), origin, no, t);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void append_grep_pat(struct grep_opt *opt, const char *pat, size_t patlen,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *origin, int no, enum grep_pat_token t)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p = create_grep_pat(pat, patlen, origin, no, t, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 do_append_grep_pat(&opt->pattern_tail, p);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "struct grep_opt *grep_opt_dup(const struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *pat;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_opt *ret = xmalloc(sizeof(struct grep_opt));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *ret = *opt;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 ret->pattern_list = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 ret->pattern_tail = &ret->pattern_list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for(pat = opt->pattern_list; pat != NULL; pat = pat->next)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if(pat->token == GREP_PATTERN_HEAD)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 append_header_grep_pattern(ret, pat->field,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pat->pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 append_grep_pat(ret, pat->pattern, pat->patternlen,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pat->origin, pat->no, pat->token);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return ret;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static NORETURN void compile_regexp_failed(const struct grep_pat *p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *error)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 char where[1024];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->no)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 xsnprintf(where, sizeof(where), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "In '%s' at %d, "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->origin, p->no);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (p->origin)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 xsnprintf(where, sizeof(where), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%s, "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->origin);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 where[0] = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%s'%s': %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", where, p->pattern, error);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int is_fixed(const char *s, size_t len)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t i;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (i = 0; i < len; i++) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (is_regex_special(s[i]))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#ifdef USE_LIBPCRE2"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#define GREP_PCRE2_DEBUG_MALLOC 0"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void *pcre2_malloc(PCRE2_SIZE size, MAYBE_UNUSED void *memory_data)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 void *pointer = malloc(size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#if GREP_PCRE2_DEBUG_MALLOC"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 static int count = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 fprintf(stderr, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "PCRE2:%p -> #%02d: alloc(%lu)\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", pointer, count++, size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return pointer;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void pcre2_free(void *pointer, MAYBE_UNUSED void *memory_data)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#if GREP_PCRE2_DEBUG_MALLOC"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 static int count = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (pointer)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 fprintf(stderr, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "PCRE2:%p -> #%02d: free()\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", pointer, count++);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 free(pointer);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void compile_pcre2_pattern(struct grep_pat *p, const struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int error;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 PCRE2_UCHAR errbuf[256];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 PCRE2_SIZE erroffset;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int options = PCRE2_MULTILINE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int jitret;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int patinforet;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t jitsizearg;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int literal = !opt->ignore_case && (p->fixed || p->is_fixed);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* Call pcre2_general_context_create() before calling any"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* other pcre2_*(). It sets up our malloc()/free() functions"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* with which everything else is allocated."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->pcre2_general_context = pcre2_general_context_create("
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pcre2_malloc, pcre2_free, NULL);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!p->pcre2_general_context)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Couldn't allocate PCRE2 general context"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->ignore_case) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!opt->ignore_locale && has_non_ascii(p->pattern)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pcre2_tables = pcre2_maketables(p->pcre2_general_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pcre2_compile_context = pcre2_compile_context_create(p->pcre2_general_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pcre2_set_character_tables(p->pcre2_compile_context,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pcre2_tables);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 options |= PCRE2_CASELESS;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->ignore_locale && is_utf8_locale() && !literal)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 options |= (PCRE2_UTF | PCRE2_MATCH_INVALID_UTF);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#ifdef GIT_PCRE2_VERSION_10_36_OR_HIGHER"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* Work around https://bugs.exim.org/show_bug.cgi?id=2642 fixed in 10.36 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (PCRE2_MATCH_INVALID_UTF && options & (PCRE2_UTF | PCRE2_CASELESS))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 options |= PCRE2_NO_START_OPTIMIZE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->pcre2_pattern = pcre2_compile((PCRE2_SPTR)p->pattern,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p->patternlen, options, &error, &erroffset,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p->pcre2_compile_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->pcre2_pattern) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 p->pcre2_match_data = pcre2_match_data_create_from_pattern(p->pcre2_pattern, p->pcre2_general_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!p->pcre2_match_data)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Couldn't allocate PCRE2 match data"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 } else {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pcre2_get_error_message(error, errbuf, sizeof(errbuf));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_regexp_failed(p, (const char *)&errbuf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_config(PCRE2_CONFIG_JIT, &p->pcre2_jit_on);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->pcre2_jit_on) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 jitret = pcre2_jit_compile(p->pcre2_pattern, PCRE2_JIT_COMPLETE);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (jitret)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Couldn't JIT the PCRE2 pattern '%s', got '%d'\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->pattern, jitret);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* The pcre2_config(PCRE2_CONFIG_JIT, ...) call just"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* tells us whether the library itself supports JIT,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* but to see whether we're going to be actually using"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* JIT we need to extract PCRE2_INFO_JITSIZE from the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* pattern *after* we do pcre2_jit_compile() above."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* This is because if the pattern contains the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* (*NO_JIT) verb (see pcre2syntax(3))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* pcre2_jit_compile() will exit early with 0. If we"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* then proceed to call pcre2_jit_match() further down"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* the line instead of pcre2_match() we'll either"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* segfault (pre PCRE 10.31) or run into a fatal error"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* (post PCRE2 10.31)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 patinforet = pcre2_pattern_info(p->pcre2_pattern, PCRE2_INFO_JITSIZE, &jitsizearg);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (patinforet)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "pcre2_pattern_info() failed: %d"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", patinforet);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (jitsizearg == 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pcre2_jit_on = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int pcre2match(struct grep_pat *p, const char *line, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regmatch_t *match, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int ret, flags = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 PCRE2_SIZE *ovector;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 PCRE2_UCHAR errbuf[256];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (eflags & REG_NOTBOL)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 flags |= PCRE2_NOTBOL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->pcre2_jit_on)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ret = pcre2_jit_match(p->pcre2_pattern, (unsigned char *)line,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eol - line, 0, flags, p->pcre2_match_data,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 NULL);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ret = pcre2_match(p->pcre2_pattern, (unsigned char *)line,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eol - line, 0, flags, p->pcre2_match_data,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 NULL);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (ret < 0 && ret != PCRE2_ERROR_NOMATCH) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pcre2_get_error_message(ret, errbuf, sizeof(errbuf));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%s failed with error code %d: %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\","
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (p->pcre2_jit_on ? \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "pcre2_jit_match"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" : \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "pcre2_match"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"), ret,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errbuf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (ret > 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ovector = pcre2_get_ovector_pointer(p->pcre2_match_data);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ret = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 match->rm_so = (int)ovector[0];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 match->rm_eo = (int)ovector[1];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return ret;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void free_pcre2_pattern(struct grep_pat *p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_compile_context_free(p->pcre2_compile_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_code_free(p->pcre2_pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_match_data_free(p->pcre2_match_data);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#ifdef GIT_PCRE2_VERSION_10_34_OR_HIGHER"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_maketables_free(p->pcre2_general_context, p->pcre2_tables);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 free((void *)p->pcre2_tables);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pcre2_general_context_free(p->pcre2_general_context);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#else /* !USE_LIBPCRE2 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void compile_pcre2_pattern(struct grep_pat *p, const struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int pcre2match(struct grep_pat *p, const char *line, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regmatch_t *match, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void free_pcre2_pattern(struct grep_pat *p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void compile_fixed_regexp(struct grep_pat *p, struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct strbuf sb = STRBUF_INIT;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int err;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int regflags = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 basic_regex_quote_buf(&sb, p->pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->ignore_case)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regflags |= REG_ICASE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 err = regcomp(&p->regexp, sb.buf, regflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 strbuf_release(&sb);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (err) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char errbuf[1024];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regerror(err, &p->regexp, errbuf, sizeof(errbuf));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_regexp_failed(p, errbuf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif /* !USE_LIBPCRE2 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int err;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int regflags = REG_NEWLINE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->word_regexp = opt->word_regexp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->ignore_case = opt->ignore_case;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->fixed = opt->fixed;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (memchr(p->pattern, 0, p->patternlen) && !opt->pcre2)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(_(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "given pattern contains NULL byte (via -f "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "<file>"
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "). This is only supported with -P under PCRE v2"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p->is_fixed = is_fixed(p->pattern, p->patternlen);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#ifdef USE_LIBPCRE2"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0if (!p->fixed && !p->is_fixed) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *no_jit = \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "(*NO_JIT)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\";"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const int no_jit_len = strlen(no_jit);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (starts_with(p->pattern, no_jit) &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0is_fixed(p->pattern + no_jit_len,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->patternlen - no_jit_len))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p->is_fixed = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->fixed || p->is_fixed) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#ifdef USE_LIBPCRE2"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (p->is_fixed) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 compile_pcre2_pattern(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 } else {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* E.g. t7811-grep-open.sh relies on the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* pattern being restored."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 char *old_pattern = p->pattern;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t old_patternlen = p->patternlen;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 struct strbuf sb = STRBUF_INIT;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* There is the PCRE2_LITERAL flag, but it's"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* only in PCRE v2 10.30 and later. Needing to"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* ifdef our way around that and dealing with"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* it + PCRE2_MULTILINE being an error is more"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* complex than just quoting this ourselves."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 strbuf_add(&sb, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\\\Q"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 2);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 strbuf_add(&sb, p->pattern, p->patternlen);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 strbuf_add(&sb, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\\\E"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 2);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pattern = sb.buf;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->patternlen = sb.len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 compile_pcre2_pattern(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->pattern = old_pattern;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p->patternlen = old_patternlen;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 strbuf_release(&sb);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#else /* !USE_LIBPCRE2 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_fixed_regexp(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "#endif /* !USE_LIBPCRE2 */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->pcre2) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_pcre2_pattern(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->ignore_case)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regflags |= REG_ICASE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->extended_regexp_option)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regflags |= REG_EXTENDED;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 err = regcomp(&p->regexp, p->pattern, regflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (err) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char errbuf[1024];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regerror(err, &p->regexp, errbuf, 1024);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_regexp_failed(p, errbuf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_not_expr(struct grep_expr *expr)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *z = xcalloc(1, sizeof(*z));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->node = GREP_NODE_NOT;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->u.unary = expr;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return z;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_binexp(enum grep_expr_node kind,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0struct grep_expr *left,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0struct grep_expr *right)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *z = xcalloc(1, sizeof(*z));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->node = kind;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->u.binary.left = left;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->u.binary.right = right;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return z;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_or_expr(struct grep_expr *left, struct grep_expr *right)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return grep_binexp(GREP_NODE_OR, left, right);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_and_expr(struct grep_expr *left, struct grep_expr *right)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return grep_binexp(GREP_NODE_AND, left, right);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_or(struct grep_pat **);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_atom(struct grep_pat **list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p = *list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN: /* atom */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_HEAD:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_PATTERN_BODY:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 CALLOC_ARRAY(x, 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x->node = GREP_NODE_ATOM;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x->u.atom = p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *list = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_OPEN_PAREN:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *list = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x = compile_pattern_or(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!*list || (*list)->token != GREP_CLOSE_PAREN)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "unmatched parenthesis"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *list = (*list)->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_not(struct grep_pat **list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p = *list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NOT:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!p->next)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--not not followed by pattern expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *list = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x = compile_pattern_not(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--not followed by non pattern expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_not_expr(x);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return compile_pattern_atom(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_and(struct grep_pat **list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *x, *y;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 x = compile_pattern_not(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p = *list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p && p->token == GREP_AND) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--and not preceded by pattern expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!p->next)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--and not followed by pattern expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *list = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 y = compile_pattern_and(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!y)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--and not followed by pattern expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_and_expr(x, y);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_or(struct grep_pat **list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *x, *y;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 x = compile_pattern_and(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p = *list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (x && p && p->token != GREP_CLOSE_PAREN) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 y = compile_pattern_or(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!y)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "not a pattern expression %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_or_expr(x, y);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *compile_pattern_expr(struct grep_pat **list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return compile_pattern_or(list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_true_expr(void)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *z = xcalloc(1, sizeof(*z));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 z->node = GREP_NODE_TRUE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return z;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *prep_header_patterns(struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *header_expr;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *(header_group[GREP_HEADER_FIELD_MAX]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 enum grep_header_field fld;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->header_list)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->header_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (p->token != GREP_PATTERN_HEAD)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "a non-header pattern in grep header list."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (p->field < GREP_HEADER_FIELD_MIN ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 GREP_HEADER_FIELD_MAX <= p->field)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "unknown header field %d"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->field);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 compile_regexp(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (fld = 0; fld < GREP_HEADER_FIELD_MAX; fld++)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 header_group[fld] = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->header_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 struct grep_expr *h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 struct grep_pat *pp = p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h = compile_pattern_atom(&pp);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!h || pp != p->next)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "malformed header expr"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!header_group[p->field]) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 header_group[p->field] = h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 header_group[p->field] = grep_or_expr(h, header_group[p->field]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 header_expr = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (fld = 0; fld < GREP_HEADER_FIELD_MAX; fld++) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!header_group[fld])"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!header_expr)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 header_expr = grep_true_expr();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 header_expr = grep_or_expr(header_group[fld], header_expr);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return header_expr;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct grep_expr *grep_splice_or(struct grep_expr *x, struct grep_expr *y)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *z = x;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (x) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 assert(x->node == GREP_NODE_OR);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (x->u.binary.right &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x->u.binary.right->node == GREP_NODE_TRUE) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x->u.binary.right = y;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x = x->u.binary.right;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return z;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void compile_grep_patterns(struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *header_expr = prep_header_patterns(opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->pattern_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN: /* atom */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_HEAD:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_BODY:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 compile_regexp(p, opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->extended = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->all_match || opt->no_body_match || header_expr)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->extended = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (!opt->extended)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 p = opt->pattern_list;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_expression = compile_pattern_expr(&p);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "incomplete pattern expression: %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", p->pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->no_body_match && opt->pattern_expression)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_expression = grep_not_expr(opt->pattern_expression);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!header_expr)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->pattern_expression)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_expression = header_expr;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else if (opt->all_match)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_expression = grep_splice_or(header_expr,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0opt->pattern_expression);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->pattern_expression = grep_or_expr(opt->pattern_expression,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0header_expr);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->all_match = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void free_pattern_expr(struct grep_expr *x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (x->node) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_TRUE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_ATOM:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_NOT:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free_pattern_expr(x->u.unary);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_AND:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_OR:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free_pattern_expr(x->u.binary.left);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free_pattern_expr(x->u.binary.right);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 free(x);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void free_grep_patterns(struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p, *n;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->pattern_list; p; p = n) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 n = p->next;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN: /* atom */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_HEAD:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_BODY:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (p->pcre2_pattern)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 free_pcre2_pattern(p);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 regfree(&p->regexp);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 free(p->pattern);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free(p);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->extended)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 free_pattern_expr(opt->pattern_expression);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static const char *end_of_line(const char *cp, unsigned long *left)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned long l = *left;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (l && *cp != '\\n') {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 l--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 cp++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *left = l;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return cp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int word_char(char ch)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return isalnum(ch) || ch == '_';"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void output_color(struct grep_opt *opt, const void *data, size_t size,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *color)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (want_color(opt->color) && color && color[0]) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, color, strlen(color));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, data, size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, GIT_COLOR_RESET, strlen(GIT_COLOR_RESET));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 } else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, data, size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void output_sep(struct grep_opt *opt, char sign)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->null_following_name)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\0"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, &sign, 1, opt->colors[GREP_COLOR_SEP]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void show_name(struct grep_opt *opt, const char *name)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 output_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->output(opt, opt->null_following_name ? \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\0"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" : \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int patmatch(struct grep_pat *p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *line, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 regmatch_t *match, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->pcre2_pattern)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 hit = !pcre2match(p, line, eol, match, eflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 hit = !regexec_buf(&p->regexp, line, eol - line, 1, match,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0eflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void strip_timestamp(const char *bol, const char **eol_p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *eol = *eol_p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (bol < --eol) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (*eol != '>')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *eol_p = ++eol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static struct {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *field;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "} header_field[] = {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 { \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "author "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 7 },"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 { \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "committer "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 10 },"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 { \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "reflog "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 7 },"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "};"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int headerless_match_one_pattern(struct grep_pat *p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 regmatch_t *pmatch, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *start = bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if ((p->token != GREP_PATTERN) &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ((p->token == GREP_PATTERN_HEAD) != (ctx == GREP_CONTEXT_HEAD)))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0again:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 hit = patmatch(p, bol, eol, pmatch, eflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (hit && p->word_regexp) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if ((pmatch[0].rm_so < 0) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eol - bol) < pmatch[0].rm_so ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (pmatch[0].rm_eo < 0) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eol - bol) < pmatch[0].rm_eo)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "regexp returned nonsense"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* Match beginning must be either beginning of the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* line, or at word boundary (i.e. the last char must"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* not be a word char). \u00a0Similarly, match end must be"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* either end of the line, or at word boundary"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* (i.e. the next char must not be a word char)."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if ( ((pmatch[0].rm_so == 0) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 !word_char(bol[pmatch[0].rm_so-1])) &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0((pmatch[0].rm_eo == (eol-bol)) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 !word_char(bol[pmatch[0].rm_eo])) )"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* Words consist of at least one character. */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (pmatch->rm_so == pmatch->rm_eo)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!hit && pmatch[0].rm_so + bol + 1 < eol) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /* There could be more than one match on the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* line, and the first match might not be"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* strict word match. \u00a0But later ones could be!"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Forward to the next possible start, i.e. the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* next position following a non-word char."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol = pmatch[0].rm_so + bol + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while (word_char(bol[-1]) && bol < eol)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eflags |= REG_NOTBOL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (bol < eol)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 goto again;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (hit) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pmatch[0].rm_so += bol - start;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pmatch[0].rm_eo += bol - start;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_one_pattern(struct grep_pat *p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0enum grep_context ctx, regmatch_t *pmatch,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *field;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (p->token == GREP_PATTERN_HEAD) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 assert(p->field < ARRAY_SIZE(header_field));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 field = header_field[p->field].field;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 len = header_field[p->field].len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (strncmp(bol, field, len))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 bol += len;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 switch (p->field) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_HEADER_AUTHOR:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_HEADER_COMMITTER:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 strip_timestamp(bol, &eol);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return headerless_match_one_pattern(p, bol, eol, ctx, pmatch, eflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_expr_eval(struct grep_opt *opt, struct grep_expr *x,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0enum grep_context ctx, ssize_t *col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ssize_t *icol, int collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int h = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Not a valid grep expression"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (x->node) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_TRUE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_ATOM:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 regmatch_t tmp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 h = match_one_pattern(x->u.atom, bol, eol, ctx,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &tmp, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (h && (*col < 0 || tmp.rm_so < *col))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 *col = tmp.rm_so;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (x->u.atom->token == GREP_PATTERN_BODY)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->body_hit |= h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_NOT:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Upon visiting a GREP_NODE_NOT, col and icol become swapped."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h = !match_expr_eval(opt, x->u.unary, bol, eol, ctx, icol, col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_AND:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h = match_expr_eval(opt, x->u.binary.left, bol, eol, ctx, col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 icol, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (h || opt->columnnum) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Don't short-circuit AND when given --column, since a"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* NOT earlier in the tree may turn this into an OR. In"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* this case, see the below comment."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 h &= match_expr_eval(opt, x->u.binary.right, bol, eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ctx, col, icol, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_NODE_OR:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!(collect_hits || opt->columnnum)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Don't short-circuit OR when given --column (or"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* collecting hits) to ensure we don't skip a later"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* child that would produce an earlier match."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return (match_expr_eval(opt, x->u.binary.left, bol, eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ctx, col, icol, 0) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 match_expr_eval(opt, x->u.binary.right, bol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eol, ctx, col, icol, 0));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h = match_expr_eval(opt, x->u.binary.left, bol, eol, ctx, col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 icol, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x->u.binary.left->hit |= h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 h |= match_expr_eval(opt, x->u.binary.right, bol, eol, ctx, col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0icol, collect_hits);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 die(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Unexpected node type (internal error) %d"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", x->node);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x->hit |= h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return h;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_expr(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx, ssize_t *col,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ssize_t *icol, int collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_expr *x = opt->pattern_expression;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return match_expr_eval(opt, x, bol, eol, ctx, col, icol, collect_hits);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_line(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ssize_t *col, ssize_t *icol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx, int collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->extended)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return match_expr(opt, bol, eol, ctx, col, icol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 collect_hits);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* we do not call with collect_hits without being extended */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->pattern_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regmatch_t tmp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (match_one_pattern(p, bol, eol, ctx, &tmp, 0)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hit |= 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!opt->columnnum) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Without --column, any single match on a line"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* is enough to know that it needs to be"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* printed. With --column, scan _all_ patterns"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* to find the earliest."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (*col < 0 || tmp.rm_so < *col)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 *col = tmp.rm_so;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_next_pattern(struct grep_pat *p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 regmatch_t *pmatch, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 regmatch_t match;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!headerless_match_one_pattern(p, bol, eol, ctx, &match, eflags))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (match.rm_so < 0 || match.rm_eo < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (pmatch->rm_so >= 0 && pmatch->rm_eo >= 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (match.rm_so > pmatch->rm_so)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (match.rm_so == pmatch->rm_so && match.rm_eo < pmatch->rm_eo)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pmatch->rm_so = match.rm_so;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pmatch->rm_eo = match.rm_eo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "int grep_next_match(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx, regmatch_t *pmatch,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 enum grep_header_field field, int eflags)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 pmatch->rm_so = pmatch->rm_eo = -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (bol < eol) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 for (p = ((ctx == GREP_CONTEXT_HEAD)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0? opt->header_list : opt->pattern_list);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 switch (p->token) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_HEAD:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ((field != GREP_HEADER_FIELD_MAX) &&"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (p->field != field))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /* fall thru */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN: /* atom */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case GREP_PATTERN_BODY:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hit |= match_next_pattern(p, bol, eol, ctx,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pmatch, eflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void show_line_header(struct grep_opt *opt, const char *name,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0unsigned lno, ssize_t cno, char sign)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->heading && opt->last_shown == 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->last_shown = lno;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->heading && opt->pathname) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_sep(opt, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->linenum) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char buf[32];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 xsnprintf(buf, sizeof(buf), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%d"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", lno);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, buf, strlen(buf), opt->colors[GREP_COLOR_LINENO]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_sep(opt, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* Treat 'cno' as the 1-indexed offset from the start of a non-context"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* line to its first match. Otherwise, 'cno' is 0 indicating that we are"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* being called with a context line."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->columnnum && cno) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char buf[32];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 xsnprintf(buf, sizeof(buf), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"PRIuMAX, (uintmax_t)cno);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, buf, strlen(buf), opt->colors[GREP_COLOR_COLUMNNO]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_sep(opt, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void show_line(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *name, unsigned lno, ssize_t cno, char sign)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int rest = eol - bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *match_color = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *line_color = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->file_break && opt->last_shown == 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->show_hunk_mark)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 } else if (opt->pre_context || opt->post_context || opt->funcbody) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->last_shown == 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->show_hunk_mark) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 2, opt->colors[GREP_COLOR_SEP]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 } else if (lno > opt->last_shown + 1) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "--"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 2, opt->colors[GREP_COLOR_SEP]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->only_matching) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* In case the line we're being called with contains more than"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* one match, leave printing each header to the loop below."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 show_line_header(opt, name, lno, cno, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->color || opt->only_matching) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regmatch_t match;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 enum grep_context ctx = GREP_CONTEXT_BODY;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 int eflags = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->color) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (sign == ':')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 match_color = opt->colors[GREP_COLOR_MATCH_SELECTED];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 match_color = opt->colors[GREP_COLOR_MATCH_CONTEXT];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (sign == ':')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 line_color = opt->colors[GREP_COLOR_SELECTED];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else if (sign == '-')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 line_color = opt->colors[GREP_COLOR_CONTEXT];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else if (sign == '=')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 line_color = opt->colors[GREP_COLOR_FUNCTION];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 while (grep_next_match(opt, bol, eol, ctx, &match,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0GREP_HEADER_FIELD_MAX, eflags)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (match.rm_so == match.rm_eo)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->only_matching)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_line_header(opt, name, lno, cno, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, bol, match.rm_so, line_color);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, bol + match.rm_so,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0match.rm_eo - match.rm_so, match_color);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->only_matching)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol += match.rm_eo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cno += match.rm_eo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rest -= match.rm_eo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eflags = REG_NOTBOL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->only_matching) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, bol, rest, line_color);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "int grep_use_locks;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "/*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* This lock protects access to the gitattributes machinery, which is"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0* not thread-safe."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "pthread_mutex_t grep_attr_mutex;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static inline void grep_attr_lock(void)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (grep_use_locks)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pthread_mutex_lock(&grep_attr_mutex);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static inline void grep_attr_unlock(void)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (grep_use_locks)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 pthread_mutex_unlock(&grep_attr_mutex);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int match_funcname(struct grep_opt *opt, struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *bol, const char *eol)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 xdemitconf_t *xecfg = opt->priv;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (xecfg && !xecfg->find_func) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_source_load_driver(gs, opt->repo->index);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (gs->driver->funcname.pattern) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const struct userdiff_funcname *pe = &gs->driver->funcname;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 xdiff_set_find_func(xecfg, pe->pattern, pe->cflags);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 } else {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 xecfg = opt->priv = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (xecfg) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char buf[1];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return xecfg->find_func(bol, eol - bol, buf, 1,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 xecfg->find_func_priv) >= 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (bol == eol)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (isalpha(*bol) || *bol == '_' || *bol == '$')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void show_funcname_line(struct grep_opt *opt, struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *bol, unsigned lno)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (bol > gs->buf) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *eol = --bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 while (bol > gs->buf && bol[-1] != '\\n')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 lno--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (lno <= opt->last_shown)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (match_funcname(opt, gs, bol, eol)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_line(opt, bol, eol, gs->name, lno, 0, '=');"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int is_empty_line(const char *bol, const char *eol);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void show_pre_context(struct grep_opt *opt, struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *bol, const char *end, unsigned lno)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned cur = lno, from = 1, funcname_lno = 0, orig_from;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int funcname_needed = !!opt->funcname, comment_needed = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->pre_context < lno)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 from = lno - opt->pre_context;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (from <= opt->last_shown)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 from = opt->last_shown + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 orig_from = from;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->funcbody) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (match_funcname(opt, gs, bol, end))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comment_needed = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 funcname_needed = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 from = opt->last_shown + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* Rewind. */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (bol > gs->buf && cur > from) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *next_bol = bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *eol = --bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 while (bol > gs->buf && bol[-1] != '\\n')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 cur--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (comment_needed && (is_empty_line(bol, eol) ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0match_funcname(opt, gs, bol, eol))) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comment_needed = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 from = orig_from;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (cur < from) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cur++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bol = next_bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (funcname_needed && match_funcname(opt, gs, bol, eol)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 funcname_lno = cur;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 funcname_needed = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->funcbody)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comment_needed = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 from = orig_from;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* We need to look even further back to find a function signature. */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->funcname && funcname_needed)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 show_funcname_line(opt, gs, bol, cur);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* Back forward. */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (cur < lno) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *eol = bol, sign = (cur == funcname_lno) ? '=' : '-';"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 while (*eol != '\\n')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 eol++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 show_line(opt, bol, eol, gs->name, cur, 0, sign);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 bol = eol + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 cur++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int should_lookahead(struct grep_opt *opt)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->extended)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0; /* punt for too complex stuff */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->invert)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->pattern_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (p->token != GREP_PATTERN)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0; /* punt for \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "header only"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" and stuff */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int look_ahead(struct grep_opt *opt,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 unsigned long *left_p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 unsigned *lno_p,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char **bol_p)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned lno = *lno_p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *bol = *bol_p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_pat *p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *sp, *last_bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 regoff_t earliest = -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (p = opt->pattern_list; p; p = p->next) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 int hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 regmatch_t m;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 hit = patmatch(p, bol, bol + *left_p, &m, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!hit || m.rm_so < 0 || m.rm_eo < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (earliest < 0 || m.rm_so < earliest)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 earliest = m.rm_so;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (earliest < 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *bol_p = bol + *left_p;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 *left_p = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (sp = bol + earliest; bol < sp && sp[-1] != '\\n'; sp--)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ; /* find the beginning of the line */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 last_bol = sp;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 for (sp = bol; sp < last_bol; sp++) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (*sp == '\\n')"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 lno++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *left_p -= last_bol - bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *bol_p = last_bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 *lno_p = lno;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int fill_textconv_grep(struct repository *r,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 struct userdiff_driver *driver,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct diff_filespec *df;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 char *buf;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!driver || !driver->textconv)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_source_load(gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* The textconv interface is intimately tied to diff_filespecs, so we"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* have to pretend to be one. If we could unify the grep_source"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* and diff_filespec structs, this mess could just go away."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 df = alloc_filespec(gs->path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (gs->type) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_OID:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 fill_filespec(df, gs->identifier, 1, 0100644);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_FILE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 fill_filespec(df, null_oid(), 0, 0100644);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "attempt to textconv something without a path?"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* fill_textconv is not remotely thread-safe; it modifies the global"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* diff tempfile structure, writes to the_repo's odb and might"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* internally call thread-unsafe functions such as the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* prepare_packed_git() lazy-initializator. Because of the last two, we"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* must ensure mutual exclusion between this call and the object reading"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* API, thus we use obj_read_lock() here."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* TODO: allowing text conversion to run in parallel with object"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* reading operations might increase performance in the multithreaded"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* non-worktreee git-grep with --textconv."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 obj_read_lock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size = fill_textconv(r, driver, df, &buf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 obj_read_unlock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 free_filespec(df);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* The normal fill_textconv usage by the diff machinery would just keep"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* the textconv'd buf separate from the diff_filespec. But much of the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* grep code passes around a grep_source and assumes that its \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "buf"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\""
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* pointer is the beginning of the thing we are searching. So let's"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* install our textconv'd version into the grep_source, taking care not"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* to leak any existing buffer."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_clear_data(gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = buf;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->size = size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int is_empty_line(const char *bol, const char *eol)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (bol < eol && isspace(*bol))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 bol++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return bol == eol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_1(struct grep_opt *opt, struct grep_source *gs, int collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *peek_bol = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned long left;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned lno = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned last_hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int binary_match_only = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 unsigned count = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int try_lookahead = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int show_function = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct userdiff_driver *textconv = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 enum grep_context ctx = GREP_CONTEXT_HEAD;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 xdemitconf_t xecfg;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->status_only && gs->name == NULL)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep call which could print a name requires "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\""
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep_source.name be non-NULL"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->output)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output = std_output;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->pre_context || opt->post_context || opt->file_break ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->funcbody) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* Show hunk marks, except for the first file. */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->last_shown)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->show_hunk_mark = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* If we're using threads then we can't easily identify"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* the first file. \u00a0Always put hunk marks in that case"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* and skip the very first one later in work_done()."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->output != std_output)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->show_hunk_mark = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->last_shown = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->allow_textconv) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_source_load_driver(gs, opt->repo->index);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* We might set up the shared textconv cache data here, which"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* is not thread-safe. Also, get_oid_with_context() and"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* parse_object() might be internally called. As they are not"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* currently thread-safe and might be racy with object reading,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* obj_read_lock() must be called."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_attr_lock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 obj_read_lock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 textconv = userdiff_get_textconv(opt->repo, gs->driver);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 obj_read_unlock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 grep_attr_unlock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* We know the result of a textconv is text, so we only have to care"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* about binary handling if we are not using it."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!textconv) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 switch (opt->binary) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_BINARY_DEFAULT:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (grep_source_is_binary(gs, opt->repo->index))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 binary_match_only = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_BINARY_NOMATCH:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (grep_source_is_binary(gs, opt->repo->index))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0; /* Assume unmatch */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 case GREP_BINARY_TEXT:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 default:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "unknown binary handling mode"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 memset(&xecfg, 0, sizeof(xecfg));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->priv = &xecfg;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 try_lookahead = should_lookahead(opt);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (fill_textconv_grep(opt->repo, textconv, gs) < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 bol = gs->buf;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 left = gs->size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (left) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 const char *eol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 int hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ssize_t cno;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 ssize_t col = -1, icol = -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* look_ahead() skips quickly to the line that possibly"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* has the next hit; don't call it if we need to do"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* something more than just skipping the current line"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* in response to an unmatch for the current line. \u00a0E.g."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* inside a post-context window, we will show the current"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* line as a context around the previous hit when it"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* doesn't hit."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (try_lookahead"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 && !(last_hit"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0&& (show_function ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0lno <= last_hit + opt->post_context))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 && look_ahead(opt, &left, &lno, &bol))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 eol = end_of_line(bol, &left);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if ((ctx == GREP_CONTEXT_HEAD) && (eol == bol))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ctx = GREP_CONTEXT_BODY;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 hit = match_line(opt, bol, eol, &col, &icol, ctx, collect_hits);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 goto next_line;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep -v -e foo -e bla"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" should list lines"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* that do not have either, so inversion should"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0* be done outside."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->invert)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hit = !hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->unmatch_name_only) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (hit)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 goto next_line;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (hit) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->status_only)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->name_only) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_name(opt, gs->name);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->count)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 goto next_line;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (binary_match_only) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "Binary file "
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 12);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, gs->name, strlen(gs->name),"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0opt->colors[GREP_COLOR_FILENAME]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": " matches\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", 9);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /* Hit at this line. \u00a0If we haven't shown the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* pre-context lines, we would need to show them."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->pre_context || opt->funcbody)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_pre_context(opt, gs, bol, eol, lno);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else if (opt->funcname)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_funcname_line(opt, gs, bol, lno);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cno = opt->invert ? icol : col;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (cno < 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* A negative cno indicates that there was no"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* match on the line. We are thus inverted and"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* being asked to show all lines that _don't_"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* match a given expression. Therefore, set cno"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* to 0 to suggest the whole line matches."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cno = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_line(opt, bol, eol, gs->name, lno, cno + 1, ':');"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 last_hit = lno;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (opt->funcbody)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_function = 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 goto next_line;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (show_function && (!peek_bol || peek_bol < bol)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 unsigned long peek_left = left;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *peek_eol = eol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Trailing empty lines are not interesting."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* Peek past them to see if they belong to the"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* body of the current function."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 peek_bol = bol;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while (is_empty_line(peek_bol, peek_eol)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 peek_bol = peek_eol + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 peek_eol = end_of_line(peek_bol, &peek_left);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (match_funcname(opt, gs, peek_bol, peek_eol))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_function = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (show_function ||"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (last_hit && lno <= last_hit + opt->post_context)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /* If the last hit is within the post context,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0* we need to show this line."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show_line(opt, bol, eol, gs->name, lno, col + 1, '-');"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 next_line:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 bol = eol + 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!left)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 left--;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 lno++;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (collect_hits)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->status_only)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return opt->unmatch_name_only;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->unmatch_name_only) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* We did not see any hit, so we want to show this */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 show_name(opt, gs->name);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 xdiff_clear_find_func(&xecfg);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->priv = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* NEEDSWORK:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* The real \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "grep -c foo *.c"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" gives many \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "bar.c:0"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" lines,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* which feels mostly useless but sometimes useful. \u00a0Maybe"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* make it another option? \u00a0For now suppress them."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->count && count) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 char buf[32];"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (opt->pathname) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_color(opt, gs->name, strlen(gs->name),"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0opt->colors[GREP_COLOR_FILENAME]);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output_sep(opt, ':');"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 xsnprintf(buf, sizeof(buf), \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "%u\\n"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\", count);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 opt->output(opt, buf, strlen(buf));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return !!last_hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void clr_hit_marker(struct grep_expr *x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* All-hit markers are meaningful only at the very top level"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* OR node."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (1) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x->hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (x->node != GREP_NODE_OR)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x->u.binary.left->hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x = x->u.binary.right;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int chk_hit_marker(struct grep_expr *x)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* Top level nodes have hit markers. \u00a0See if they all are hits */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 while (1) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (x->node != GREP_NODE_OR)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return x->hit;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (!x->u.binary.left->hit)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 x = x->u.binary.right;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "int grep_source(struct grep_opt *opt, struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /*"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* we do not have to do the two-pass grep when we do not check"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* buffer-wide \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "all-match"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!opt->all_match && !opt->no_body_match)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_source_1(opt, gs, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 /* Otherwise the toplevel \""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "or"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\" terms hit a bit differently."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0* We first clear hit markers from them."
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0*/"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 clr_hit_marker(opt->pattern_expression);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 opt->body_hit = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_1(opt, gs, 1);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->all_match && !chk_hit_marker(opt->pattern_expression))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (opt->no_body_match && opt->body_hit)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return grep_source_1(opt, gs, 0);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static void grep_source_init_buf(struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *buf,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0unsigned long size)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->type = GREP_SOURCE_BUF;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->name = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->path = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = buf;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->size = size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->driver = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->identifier = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "int grep_buffer(struct grep_opt *opt, const char *buf, unsigned long size)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct grep_source gs;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int r;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_init_buf(&gs, buf, size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 r = grep_source(opt, &gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_clear(&gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return r;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_source_init_file(struct grep_source *gs, const char *name,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0const char *path)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->type = GREP_SOURCE_FILE;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->name = xstrdup_or_null(name);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->path = xstrdup_or_null(path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->size = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->driver = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->identifier = xstrdup(path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_source_init_oid(struct grep_source *gs, const char *name,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const char *path, const struct object_id *oid,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 struct repository *repo)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->type = GREP_SOURCE_OID;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->name = xstrdup_or_null(name);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->path = xstrdup_or_null(path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->size = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->driver = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->identifier = oiddup(oid);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->repo = repo;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_source_clear(struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 FREE_AND_NULL(gs->name);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 FREE_AND_NULL(gs->path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 FREE_AND_NULL(gs->identifier);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_clear_data(gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_source_clear_data(struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (gs->type) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_FILE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_OID:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* these types own the buffer */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free((char *)gs->buf);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 gs->buf = NULL;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 gs->size = 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_BUF:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 /* leave user-provided buf intact */"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 break;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_load_oid(struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 enum object_type type;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = repo_read_object_file(gs->repo, gs->identifier, &type,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &gs->size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!gs->buf)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return error(_(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "'%s': unable to read %s"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"),"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0gs->name,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0oid_to_hex(gs->identifier));"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_load_file(struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 const char *filename = gs->identifier;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 struct stat st;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 char *data;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size_t size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 int i;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (lstat(filename, &st) < 0) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 err_ret:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 if (errno != ENOENT)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 error_errno(_(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "failed to stat '%s'"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"), filename);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!S_ISREG(st.st_mode))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 size = xsize_t(st.st_size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 i = open(filename, O_RDONLY);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (i < 0)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 goto err_ret;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 data = xmallocz(size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (st.st_size != read_in_full(i, data, size)) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 error_errno(_(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "'%s': short read"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\"), filename);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 close(i);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 free(data);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 close(i);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->buf = data;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 gs->size = size;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_load(struct grep_source *gs)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (gs->buf)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 switch (gs->type) {"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_FILE:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_source_load_file(gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_OID:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return grep_source_load_oid(gs);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 case GREP_SOURCE_BUF:"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return gs->buf ? 0 : -1;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 }"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 BUG(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "invalid grep_source type to load"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "void grep_source_load_driver(struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0struct index_state *istate)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (gs->driver)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_attr_lock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (gs->path)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 gs->driver = userdiff_find_by_path(istate, gs->path);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!gs->driver)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 gs->driver = userdiff_find_by_name(\""
    },
    {
      "color": {
        "cct": 6755.04,
        "value": "#d5ced9"
      },
      "content": "default"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\");"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_attr_unlock();"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "static int grep_source_is_binary(struct grep_source *gs,"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0struct index_state *istate)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "{"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 grep_source_load_driver(gs, istate);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (gs->driver->binary != -1)"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return gs->driver->binary;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 if (!grep_source_load(gs))"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 \u00a0 \u00a0 return buffer_is_binary(gs->buf, gs->size);"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "\u00a0 \u00a0 return 0;"
    },
    {
      "color": {
        "cct": 5619.32,
        "value": "#96e072"
      },
      "content": "}"
    }
  ],
  "style": {
    "background-color": {
      "cct": 9799.61,
      "value": "#23262e"
    },
    "color": {
      "cct": 6755.04,
      "value": "#d5ced9"
    },
    "font-family": [
      "Consolas",
      "Courier New",
      "monospace"
    ],
    "font-size": "14px",
    "font-weight": "normal",
    "line-height": "19px",
    "white-space": "pre"
  }
}
